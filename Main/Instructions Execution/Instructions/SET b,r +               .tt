<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="_Utils.t4"#>
<#@ output extension=".cs" #>
<#AutoGeneratedCodeWarning(); #>

using System;

namespace Konamiman.Z80dotNet
{
    public partial class Z80InstructionExecutor
    {
<#  foreach(var reg in new[] {"A", "B", "C", "D", "E", "H", "L", "(HL)", "(IX+n)", "(IY+n)"}) {
    foreach(var isSet in new[] {true, false}) {
	foreach (var destRegName in new[] {"A", "B", "C", "D", "E", "H", "L", ""}) {
    for(var bit = 0; bit <= 7; bit++) {
            var isMemHL = (reg == "(HL)");
			var isMemIndex = (reg.StartsWith("(I"));
			if(destRegName != "" && !isMemIndex) continue;
            var setRes = isSet ? "SET" : "RES";
            var instrName = String.Format("{0} {1},{2}", setRes, bit, reg);
			if(destRegName != "") instrName += "," + destRegName;
            var methodName = String.Format("{0}_{1}_{2}", setRes, bit, MethodRegPartName(reg, destRegName)); #>
		/// <summary>
        /// The <#=instrName #> instruction
        /// </summary>
        byte <#=methodName #>(<#=isMemIndex ? "byte offset" : "" #>)
        {
            FetchFinished();

<# GetOldValueFromRegOrMem(reg); #>
        var newValue = oldValue.WithBit(<#=bit #>, <#=isSet ? 1 : 0#>);
<# SetNewValueToRegOrMem(reg); #>
<# if(destRegName != "") { #>
		Registers.<#=destRegName#> = newValue;
<# } #>

			return <#=isMemHL ? 15 : isMemIndex ? 23 : 8 #>;
        }

<# }}}} #>
	}
}
